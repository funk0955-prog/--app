<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MyBoardï¼ˆæ‰‹æ©Ÿå„ªåŒ–ç‰ˆï¼‰</title>
  <style>
    :root{
      --bg:#f3f4f6;
      --card:#ffffff;
      --ink:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --accent:#2563eb;
      --danger:#dc2626;
      --shadow: 0 10px 25px rgba(0,0,0,.08);
      --radius:14px;

      /* âœ… è®“ board-wrap çš„ top ä¾ topbar å¯¦éš›é«˜åº¦ */
      --topbar-h: 56px;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans TC","PingFang TC","Heiti TC",Arial,sans-serif; color:var(--ink);}
    body{background:var(--bg); overflow:hidden;}

    /* âœ… Topbarï¼šæ‰‹æ©Ÿä¸æ›è¡Œ + å¯å·¦å³æ»‘å‹• + safe area */
    .topbar{
      position:fixed; left:0; right:0; top:0;
      min-height:56px;
      height:auto;
      display:flex; align-items:center; gap:10px;
      padding: calc(env(safe-area-inset-top, 0px) + 8px) 12px 8px;
      background:rgba(243,244,246,.92); backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
      z-index:10;

      flex-wrap: nowrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      white-space: nowrap;
    }
    .topbar::-webkit-scrollbar{display:none;}
    .topbar > *{flex:0 0 auto;}

    .btn{
      height:38px; padding:0 12px; border:1px solid var(--line); border-radius:10px;
      background:var(--card); color:var(--ink); cursor:pointer; font-weight:700;
      display:inline-flex; align-items:center; gap:8px;
      user-select:none;
    }
    .btn:active{transform:translateY(1px)}
    .btn.primary{border-color:transparent; background:var(--accent); color:white;}
    .btn.danger{border-color:transparent; background:var(--danger); color:white;}

    .pill{
      height:38px; padding:0 12px; border-radius:999px; border:1px solid var(--line);
      background:var(--card); display:flex; align-items:center; gap:10px;
      color:var(--muted); font-weight:800;
    }
    .hint{font-size:12px; color:var(--muted); font-weight:700;}
    .spacer{flex:1}

    /* âœ… board-wrapï¼štop ç”¨è®Šæ•¸ï¼Œä¸å†å¯«æ­» 56px */
    .board-wrap{
      position:fixed; left:0; right:0; top:var(--topbar-h); bottom:0;
      overflow:hidden;
      /* iOS æ»‘å‹•æ›´é † */
      -webkit-overflow-scrolling: touch;
    }

    .board{
      position:absolute; inset:0;
      transform-origin: 0 0;
      background:
        radial-gradient(circle at 1px 1px, rgba(17,24,39,.10) 1px, transparent 1px);
      background-size: 22px 22px;
      touch-action:none;
    }

    /* SVG links layer */
    svg#linksLayer{
      position:absolute; inset:0; pointer-events:none;
    }

    /* Cards */
    .card{
      position:absolute;
      width:260px;
      min-height:120px;
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      touch-action:none;
    }
    .card.selected{outline:2px solid var(--accent);}

    .card .header{
      display:flex; align-items:center; gap:8px;
      padding:10px 10px 8px;
      border-bottom:1px solid var(--line);
      background:linear-gradient(to bottom, rgba(243,244,246,.9), rgba(255,255,255,1));
      cursor:grab;
      user-select:none;
    }
    .card .header:active{cursor:grabbing;}

    .card .title{
      flex:1;
      font-weight:900;
      border:none;
      background:transparent;
      font-size:14px;
      outline:none;
      padding:2px 4px;
      border-radius:8px;
      min-width: 0;
    }

    .card .tools{
      display:flex; gap:6px; align-items:center;
    }

    .iconbtn{
      width:30px; height:30px; border-radius:9px;
      border:1px solid var(--line); background:white;
      cursor:pointer; font-size:14px; font-weight:900;
      display:flex; align-items:center; justify-content:center;
      user-select:none;
    }
    .iconbtn:active{transform:translateY(1px)}

    .card .body{padding:10px;}

    .note{
      width:100%;
      min-height:54px;
      resize:vertical;
      border:1px dashed var(--line);
      border-radius:12px;
      padding:10px;
      outline:none;
      font-size:13px;
      line-height:1.35;
      background:#fff;
    }

    .todo{
      margin-top:10px;
      border-top:1px solid var(--line);
      padding-top:10px;
    }

    .todo-row{
      display:flex; gap:8px; align-items:center; margin:6px 0;
    }

    .todo-row input[type="text"]{
      flex:1;
      border:1px solid var(--line);
      border-radius:10px;
      padding:8px 10px;
      outline:none;
      font-size:13px;
      min-width:0;
    }

    .todo-list{display:flex; flex-direction:column; gap:8px; margin-top:10px;}

    .todo-item{
      display:flex; gap:10px; align-items:flex-start;
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius:12px;
      background:#fff;
    }
    .todo-item input[type="checkbox"]{margin-top:2px; transform:scale(1.1);}
    .todo-item .txt{
      flex:1;
      border:none;
      outline:none;
      background:transparent;
      font-size:13px;
      line-height:1.3;
      resize:none;
    }
    .todo-item .x{
      border:none; background:transparent; cursor:pointer; color:var(--muted);
      font-weight:900; font-size:14px; padding:0 6px;
      user-select:none;
    }

    .imgbox{
      margin-top:10px;
      border:1px dashed var(--line);
      border-radius:12px;
      padding:10px;
      display:flex; flex-direction:column; gap:8px;
      background:#fff;
    }
    .imgbox img{
      max-width:100%;
      border-radius:10px;
      border:1px solid var(--line);
    }
    .img-actions{display:flex; gap:8px; align-items:center;}
    .small{font-size:12px; color:var(--muted); font-weight:800;}
    .file{display:none;}

    .status{
      position:fixed; left:12px; bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
      padding:10px 12px; border-radius:12px;
      background:rgba(255,255,255,.9); backdrop-filter: blur(8px);
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      z-index:20;
      font-size:12px; color:var(--muted); font-weight:900;
    }

    /* âœ… æ‰‹æ©Ÿï¼šç¸®çŸ­æŒ‰éˆ•ã€éš±è—æç¤º pillï¼Œé¿å…å¤ªæ“  */
    @media (max-width: 480px){
      .pill{ display:none; }
      .btn{ height:36px; padding:0 10px; font-weight:800; }
      .iconbtn{ width:32px; height:32px; }
    }
  </style>
</head>
<body>
  <div class="topbar">
    <button class="btn primary" id="addCard">ï¼‹ æ–°å¢å¡ç‰‡</button>
    <button class="btn" id="linkMode">â†’ é€£ç·šï¼šé—œ</button>
    <button class="btn" id="fit">â–£ ç½®ä¸­</button>

    <div class="pill">
      <span class="hint">æç¤ºï¼š</span>
      <span id="modeHint">æ‹–æ›³å¡ç‰‡ï¼›é»ã€Œé€£ç·šã€å¾Œä¾åºé»å…©å¼µå¡ã€‚</span>
    </div>

    <div class="spacer"></div>

    <button class="btn" id="export">åŒ¯å‡º</button>
    <button class="btn" id="importBtn">åŒ¯å…¥</button>
    <input class="file" type="file" id="importFile" accept="application/json" />
    <button class="btn danger" id="wipe">æ¸…ç©º</button>
  </div>

  <div class="board-wrap" id="wrap">
    <div class="board" id="board">
      <svg id="linksLayer">
        <defs>
          <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#2563eb"></path>
          </marker>
        </defs>
      </svg>
    </div>
  </div>

  <div class="status" id="status">å·²è‡ªå‹•å„²å­˜</div>

  <script>
    // ====== Data model ======
    // data = { zoom:1, pan:{x,y}, cards:[{id,x,y,w,title,note,todos:[{id,done,text}], imageDataUrl?}], links:[{from,to}] }

    const LS_KEY = "myboard_v1"; // âœ… ä¸æ”¹é€™å€‹ï¼Œè³‡æ–™å°±ä¸æœƒæ¶ˆå¤±
    const boardEl = document.getElementById("board");
    const wrapEl = document.getElementById("wrap");
    const linksSvg = document.getElementById("linksLayer");
    const statusEl = document.getElementById("status");
    const modeHintEl = document.getElementById("modeHint");
    const linkModeBtn = document.getElementById("linkMode");

    let data = load() || {
      zoom: 1,
      pan: { x: 0, y: 0 },
      cards: [],
      links: []
    };

    let linkMode = false;
    let linkFrom = null;
    let selectedCardId = null;

    // âœ… è®“ board-wrap çš„ top è·Ÿè‘— topbar å¯¦éš›é«˜åº¦ï¼ˆæ‰‹æ©Ÿä¸æœƒé®ä½ç•«é¢ï¼‰
    const topbarEl = document.querySelector(".topbar");
    function syncTopbarHeight(){
      const h = topbarEl.offsetHeight;
      document.documentElement.style.setProperty("--topbar-h", h + "px");
    }

    // ====== Utilities ======
    const uid = () => Math.random().toString(36).slice(2, 10) + Date.now().toString(36).slice(2, 6);

    function save() {
      localStorage.setItem(LS_KEY, JSON.stringify(data));
      toast("å·²è‡ªå‹•å„²å­˜");
    }

    function load() {
      try {
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    let toastT = null;
    function toast(msg) {
      statusEl.textContent = msg;
      statusEl.style.opacity = "1";
      clearTimeout(toastT);
      toastT = setTimeout(() => statusEl.style.opacity = "0.85", 900);
    }

    function setTransform() {
      boardEl.style.transform = `translate(${data.pan.x}px, ${data.pan.y}px) scale(${data.zoom})`;
      drawLinks();
    }

    function getCardCenter(card) {
      return { cx: card.x + (card.w || 260)/2, cy: card.y + 60 }; // roughly header+body
    }

    function findCard(id){ return data.cards.find(c => c.id === id); }

    // ====== Rendering ======
    function clearDOMCards() {
      [...boardEl.querySelectorAll(".card")].forEach(el => el.remove());
    }

    function render() {
      clearDOMCards();

      // keep SVG full size
      const rect = wrapEl.getBoundingClientRect();
      linksSvg.setAttribute("width", rect.width);
      linksSvg.setAttribute("height", rect.height);

      data.cards.forEach(card => {
        const el = document.createElement("div");
        el.className = "card";
        el.dataset.id = card.id;
        el.style.left = card.x + "px";
        el.style.top = card.y + "px";
        el.style.width = (card.w || 260) + "px";

        el.innerHTML = `
          <div class="header">
            <input class="title" value="${escapeHtml(card.title || "æœªå‘½å")}" />
            <div class="tools">
              <button class="iconbtn" title="è²¼åœ–ç‰‡">ğŸ–¼</button>
              <button class="iconbtn" title="åˆªé™¤">âœ•</button>
            </div>
          </div>
          <div class="body">
            <textarea class="note" placeholder="ç­†è¨˜...">${escapeHtml(card.note || "")}</textarea>

            <div class="imgbox" style="${card.imageDataUrl ? "" : "display:none"}">
              <div class="small">åœ–ç‰‡</div>
              <img src="${card.imageDataUrl || ""}" />
              <div class="img-actions">
                <button class="btn" data-act="removeImg" style="height:34px">ç§»é™¤åœ–ç‰‡</button>
              </div>
            </div>

            <div class="todo">
              <div class="small">ä»£è¾¦</div>
              <div class="todo-row">
                <input type="text" placeholder="è¼¸å…¥ä»£è¾¦å¾ŒæŒ‰ Enter" class="newTodo" />
                <button class="btn" data-act="addTodo" style="height:34px">æ–°å¢</button>
              </div>
              <div class="todo-list"></div>
            </div>
          </div>
          <input class="file imgfile" type="file" accept="image/*" />
        `;

        boardEl.appendChild(el);

        // Selection + link mode click
        el.addEventListener("pointerdown", (e) => {
          if (["INPUT","TEXTAREA","BUTTON"].includes(e.target.tagName)) return;
          selectCard(card.id);
        });

        el.addEventListener("click", (e) => {
          if (!linkMode) return;
          if (["INPUT","TEXTAREA"].includes(e.target.tagName)) return;
          handleLinkClick(card.id);
        });

        // title/note binding
        const titleInput = el.querySelector(".title");
        titleInput.addEventListener("input", () => {
          card.title = titleInput.value;
          save();
        });

        const noteTa = el.querySelector(".note");
        noteTa.addEventListener("input", () => {
          card.note = noteTa.value;
          save();
        });

        // tools: image + delete
        const toolBtns = el.querySelectorAll(".iconbtn");
        const imgBtn = toolBtns[0];
        const delBtn = toolBtns[1];
        const imgFile = el.querySelector(".imgfile");

        imgBtn.addEventListener("click", () => imgFile.click());
        imgFile.addEventListener("change", async () => {
          const f = imgFile.files?.[0];
          if (!f) return;
          const url = await fileToDataUrl(f);
          card.imageDataUrl = url;
          save();
          render();
          drawLinks();
        });

        delBtn.addEventListener("click", () => {
          if (!confirm("åˆªé™¤é€™å¼µå¡ç‰‡ï¼Ÿç›¸é—œç®­é ­ä¹Ÿæœƒä¸€èµ·åˆªæ‰ã€‚")) return;
          data.cards = data.cards.filter(c => c.id !== card.id);
          data.links = data.links.filter(l => l.from !== card.id && l.to !== card.id);
          if (selectedCardId === card.id) selectedCardId = null;
          if (linkFrom === card.id) linkFrom = null;
          save();
          render();
          drawLinks();
        });

        // remove img
        const removeImgBtn = el.querySelector('[data-act="removeImg"]');
        if (removeImgBtn) {
          removeImgBtn.addEventListener("click", () => {
            delete card.imageDataUrl;
            save();
            render();
            drawLinks();
          });
        }

        // todos
        const list = el.querySelector(".todo-list");
        list.innerHTML = "";
        (card.todos || []).forEach(t => {
          const item = document.createElement("div");
          item.className = "todo-item";
          item.innerHTML = `
            <input type="checkbox" ${t.done ? "checked":""}/>
            <textarea class="txt" rows="1">${escapeHtml(t.text || "")}</textarea>
            <button class="x" title="åˆªé™¤">âœ•</button>
          `;
          const cb = item.querySelector("input[type=checkbox]");
          const txt = item.querySelector(".txt");
          const x = item.querySelector(".x");
          cb.addEventListener("change", () => { t.done = cb.checked; save(); });
          txt.addEventListener("input", () => { t.text = txt.value; save(); autoGrow(txt); });
          x.addEventListener("click", () => {
            card.todos = (card.todos || []).filter(tt => tt.id !== t.id);
            save(); render(); drawLinks();
          });
          list.appendChild(item);
          autoGrow(txt);
        });

        const newTodo = el.querySelector(".newTodo");
        const addTodoBtn = el.querySelector('[data-act="addTodo"]');
        const addTodo = () => {
          const v = (newTodo.value || "").trim();
          if (!v) return;
          card.todos = card.todos || [];
          card.todos.push({ id: uid(), done:false, text:v });
          newTodo.value = "";
          save(); render(); drawLinks();
        };
        addTodoBtn.addEventListener("click", addTodo);
        newTodo.addEventListener("keydown", (e) => {
          if (e.key === "Enter") { e.preventDefault(); addTodo(); }
        });

        // drag via header
        const header = el.querySelector(".header");
        makeDraggable(el, header, card);
      });

      // re-apply selection highlight
      if (selectedCardId) {
        const sel = boardEl.querySelector(`.card[data-id="${CSS.escape(selectedCardId)}"]`);
        if (sel) sel.classList.add("selected");
      }

      syncTopbarHeight();
      setTransform();
      drawLinks();
    }

    function escapeHtml(str){
      return (str ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function autoGrow(ta){
      ta.style.height = "auto";
      ta.style.height = Math.min(180, ta.scrollHeight) + "px";
    }

    function fileToDataUrl(file){
      return new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = () => res(r.result);
        r.onerror = rej;
        r.readAsDataURL(file);
      });
    }

    // ====== Draggable ======
    function makeDraggable(cardEl, handleEl, card) {
      let dragging = false;
      let startX=0, startY=0, origX=0, origY=0;

      handleEl.addEventListener("pointerdown", (e) => {
        if (["INPUT","TEXTAREA","BUTTON"].includes(e.target.tagName)) return;
        dragging = true;
        selectCard(card.id);
        cardEl.setPointerCapture(e.pointerId);
        handleEl.style.cursor = "grabbing";
        startX = e.clientX;
        startY = e.clientY;
        origX = card.x;
        origY = card.y;
      });

      cardEl.addEventListener("pointermove", (e) => {
        if (!dragging) return;
        const dx = (e.clientX - startX) / data.zoom;
        const dy = (e.clientY - startY) / data.zoom;
        card.x = origX + dx;
        card.y = origY + dy;
        cardEl.style.left = card.x + "px";
        cardEl.style.top = card.y + "px";
        drawLinks();
      });

      cardEl.addEventListener("pointerup", () => {
        if (!dragging) return;
        dragging = false;
        handleEl.style.cursor = "grab";
        save();
      });
    }

    // ====== Links ======
    function handleLinkClick(cardId){
      selectCard(cardId);
      if (!linkFrom) {
        linkFrom = cardId;
        toast("å·²é¸èµ·é»ï¼Œè«‹å†é»çµ‚é»å¡ç‰‡");
        return;
      }
      if (linkFrom === cardId) {
        linkFrom = null;
        toast("å–æ¶ˆé¸èµ·é»");
        return;
      }
      if (!data.links.some(l => l.from === linkFrom && l.to === cardId)) {
        data.links.push({ from: linkFrom, to: cardId });
        save();
      }
      linkFrom = null;
      toast("å·²å»ºç«‹ç®­é ­é€£ç·š");
      drawLinks();
    }

    function drawLinks(){
      [...linksSvg.querySelectorAll("line,path")].forEach(n => n.remove());

      const toScreen = (pt) => ({
        x: (pt.x * data.zoom) + data.pan.x,
        y: (pt.y * data.zoom) + data.pan.y
      });

      data.links.forEach(l => {
        const a = findCard(l.from);
        const b = findCard(l.to);
        if (!a || !b) return;

        const ca = getCardCenter(a);
        const cb = getCardCenter(b);
        const A = toScreen({x:ca.cx, y:ca.cy});
        const B = toScreen({x:cb.cx, y:cb.cy});

        const dx = Math.max(40, Math.abs(B.x - A.x) * 0.35);
        const c1 = { x: A.x + (B.x > A.x ? dx : -dx), y: A.y };
        const c2 = { x: B.x - (B.x > A.x ? dx : -dx), y: B.y };

        const path = document.createElementNS("http://www.w3.org/2000/svg","path");
        path.setAttribute("d", `M ${A.x} ${A.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${B.x} ${B.y}`);
        path.setAttribute("fill","none");
        path.setAttribute("stroke","#2563eb");
        path.setAttribute("stroke-width","3");
        path.setAttribute("stroke-linecap","round");
        path.setAttribute("marker-end","url(#arrow)");
        linksSvg.appendChild(path);
      });
    }

    // ====== Selection ======
    function selectCard(id){
      selectedCardId = id;
      [...boardEl.querySelectorAll(".card")].forEach(el => el.classList.remove("selected"));
      const el = boardEl.querySelector(`.card[data-id="${CSS.escape(id)}"]`);
      if (el) el.classList.add("selected");
    }

    // ====== Board pan/zoom ======
    let panning = false, panStart={x:0,y:0}, panOrig={x:0,y:0};

    boardEl.addEventListener("pointerdown", (e) => {
      if (e.target.closest(".card")) return;
      if (e.button !== undefined && e.button !== 0) return;
      panning = true;
      boardEl.setPointerCapture(e.pointerId);
      panStart = { x: e.clientX, y: e.clientY };
      panOrig = { x: data.pan.x, y: data.pan.y };
    });
    boardEl.addEventListener("pointermove", (e) => {
      if (!panning) return;
      data.pan.x = panOrig.x + (e.clientX - panStart.x);
      data.pan.y = panOrig.y + (e.clientY - panStart.y);
      setTransform();
    });
    boardEl.addEventListener("pointerup", () => {
      if (!panning) return;
      panning = false;
      save();
    });

    // pinch zoom
    const pointers = new Map();
    let pinchStart = null;

    wrapEl.addEventListener("pointerdown", (e) => {
      pointers.set(e.pointerId, {x:e.clientX,y:e.clientY});
      if (pointers.size === 2) {
        const pts = [...pointers.values()];
        pinchStart = {
          dist: distance(pts[0], pts[1]),
          zoom: data.zoom
        };
      }
    }, {passive:true});

    wrapEl.addEventListener("pointermove", (e) => {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, {x:e.clientX,y:e.clientY});
      if (pointers.size === 2 && pinchStart) {
        const pts = [...pointers.values()];
        const d = distance(pts[0], pts[1]);
        let z = pinchStart.zoom * (d / pinchStart.dist);
        z = Math.max(0.5, Math.min(1.8, z));
        data.zoom = z;
        setTransform();
      }
    }, {passive:true});

    wrapEl.addEventListener("pointerup", (e) => {
      pointers.delete(e.pointerId);
      if (pointers.size < 2) pinchStart = null;
      save();
    }, {passive:true});

    function distance(a,b){
      const dx=a.x-b.x, dy=a.y-b.y;
      return Math.sqrt(dx*dx+dy*dy);
    }

    // ====== Buttons ======
    document.getElementById("addCard").addEventListener("click", () => {
      const id = uid();
      const x = (-data.pan.x)/data.zoom + 40;
      const y = (-data.pan.y)/data.zoom + 40;
      data.cards.push({
        id, x, y,
        w: 260,
        title: "ä»Šæ—¥æœ€è©²åš",
        note: "",
        todos: []
      });
      save();
      render();
      selectCard(id);
    });

    linkModeBtn.addEventListener("click", () => {
      linkMode = !linkMode;
      linkFrom = null;
      linkModeBtn.textContent = `â†’ é€£ç·šï¼š${linkMode ? "é–‹" : "é—œ"}`;
      if (modeHintEl) {
        modeHintEl.textContent = linkMode
          ? "é€£ç·šæ¨¡å¼ï¼šä¾åºé»å…©å¼µå¡ç‰‡å»ºç«‹ç®­é ­ã€‚"
          : "æ‹–æ›³å¡ç‰‡ï¼›é»ã€Œé€£ç·šã€å¾Œä¾åºé»å…©å¼µå¡ã€‚";
      }
      toast(linkMode ? "é€£ç·šæ¨¡å¼å·²é–‹" : "é€£ç·šæ¨¡å¼å·²é—œ");
    });

    document.getElementById("fit").addEventListener("click", () => {
      data.zoom = 1;
      data.pan = { x: 0, y: 0 };
      save();
      syncTopbarHeight();
      setTransform();
      toast("å·²ç½®ä¸­");
    });

    document.getElementById("wipe").addEventListener("click", () => {
      if (!confirm("ç¢ºå®šæ¸…ç©ºæ‰€æœ‰å¡ç‰‡èˆ‡ç®­é ­ï¼Ÿï¼ˆä¸å¯å¾©åŸï¼‰")) return;
      data = { zoom:1, pan:{x:0,y:0}, cards:[], links:[] };
      save();
      render();
    });

    document.getElementById("export").addEventListener("click", () => {
      const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "myboard.json";
      a.click();
      URL.revokeObjectURL(a.href);
    });

    document.getElementById("importBtn").addEventListener("click", () => {
      document.getElementById("importFile").click();
    });

    document.getElementById("importFile").addEventListener("change", async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      const text = await f.text();
      try{
        const obj = JSON.parse(text);
        if (!obj || !Array.isArray(obj.cards) || !Array.isArray(obj.links)) throw new Error();
        data = obj;
        save();
        render();
        toast("åŒ¯å…¥å®Œæˆ");
      }catch{
        alert("åŒ¯å…¥å¤±æ•—ï¼šæª”æ¡ˆæ ¼å¼ä¸æ­£ç¢º");
      }finally{
        e.target.value = "";
      }
    });

    // ====== Boot ======
    syncTopbarHeight();
    window.addEventListener("resize", () => { syncTopbarHeight(); render(); drawLinks(); });

    if (data.cards.length === 0) {
      data.cards.push(
        { id: uid(), x: 60, y: 60, w: 280, title: "ä»Šæ—¥æœ€è©²åš", note:"æŠŠä»Šå¤©æœ€é‡è¦çš„ 1~3 ä»¶äº‹å¯«åœ¨é€™è£¡ã€‚", todos:[
          {id:uid(), done:false, text:"å…ˆåšæœ€èƒ½å¸¶ç¾é‡‘æµçš„äº‹"},
          {id:uid(), done:false, text:"æŠŠæœƒå¡ä½çš„é»å¯«æˆä¸‹ä¸€æ­¥"}
        ]},
        { id: uid(), x: 380, y: 120, w: 280, title: "æƒ³æ³•/ç­†è¨˜", note:"éˆæ„Ÿã€è©±è¡“ã€æ–‡æ¡ˆã€æµç¨‹éƒ½ä¸Ÿé€™è£¡ã€‚", todos:[]}
      );
      save();
    }
    render();
  </script>
</body>
</html>
